{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":5275635551912456715,"abi":{"parameters":[{"name":"old_sender_c1","type":{"kind":"field"},"visibility":"public"},{"name":"old_sender_c2","type":{"kind":"field"},"visibility":"public"},{"name":"old_receiver_c1","type":{"kind":"field"},"visibility":"public"},{"name":"old_receiver_c2","type":{"kind":"field"},"visibility":"public"},{"name":"new_sender_c1","type":{"kind":"field"},"visibility":"public"},{"name":"new_sender_c2","type":{"kind":"field"},"visibility":"public"},{"name":"new_receiver_c1","type":{"kind":"field"},"visibility":"public"},{"name":"new_receiver_c2","type":{"kind":"field"},"visibility":"public"},{"name":"secret_scalar","type":{"kind":"field"},"visibility":"private"},{"name":"transfer_amount","type":{"kind":"field"},"visibility":"private"},{"name":"receiver_pubkey_x","type":{"kind":"field"},"visibility":"private"},{"name":"receiver_pubkey_y","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/7WT0QrDIAxFte3WbvuZxGiNb/uVyez/f8KUZSCMPjW9cLkv4UC80ZqvHtWD+dck+ZSEY0JN1tCxCFbvS3QFCV/gUuYAPuSVkTFweDsmKuw5ppwiJPRUcAuJNoFNiqyr3o5wZhdWkTUqvt9FkTUrdmG7Dn65VN+q7/KHlq6vNt9udJT5tle7jdns6wMp2AGjkAMAAA==","debug_symbols":"bY1LCsMgFEX38sYONA0O3EopwW8QRMVPoUj2Xg0VUsjsnXs59zVQWtR9s96EDOzZwAXJiw2+UwN8RjlyPygXngowsuAVgfZqnCs9EBjrNDBKjhcCcq9QPJUHXv6UDiJZ5+y+XX/3+M2T5cLpH5rq5aUtnzib6ccUpFY16bF0dn3+Cw==","file_map":{"61":{"source":"// Helper to simulate ElGamal subtraction (simplified representation)\n// Normally you'd use EC point operations or simulate them\nfn subtract_cipher(c1a: Field, c2a: Field, c1b: Field, c2b: Field) -> (Field, Field) {\n    (c1a - c1b, c2a - c2b)\n}\n\nfn add_cipher(c1a: Field, c2a: Field, c1b: Field, c2b: Field) -> (Field, Field) {\n    (c1a + c1b, c2a + c2b)\n}\n\nfn main(\n    old_sender_c1: pub Field,\n    old_sender_c2: pub  Field,\n    old_receiver_c1: pub Field,\n    old_receiver_c2: pub Field,\n    new_sender_c1: pub Field,\n    new_sender_c2: pub Field,\n    new_receiver_c1: pub Field,\n    new_receiver_c2: pub Field,\n\n    secret_scalar: Field,\n    transfer_amount: Field,\n    receiver_pubkey_x: Field,\n    receiver_pubkey_y: Field\n) {\n    // Compute transfer_cipher off-chain: Enc(amount) = (g^r, m*pk^r)\n    // You commit to that amount in the proof, just check the delta logic\n\n    let (expected_sender_c1, expected_sender_c2) = subtract_cipher(\n        old_sender_c1, old_sender_c2,\n        new_sender_c1, new_sender_c2\n    );\n\n    let (expected_receiver_c1, expected_receiver_c2) = subtract_cipher(\n        new_receiver_c1, new_receiver_c2,\n        old_receiver_c1, old_receiver_c2\n    );\n\n    assert(expected_sender_c1 == expected_receiver_c1);\n    assert(expected_sender_c2 == expected_receiver_c2);\n\n    // Optional: add nullifier to prevent double-transfer\n    // let nullifier = poseidon([secret_scalar, transfer_amount, receiver_pubkey_x, receiver_pubkey_y]);\n    // pub nullifier: Field;\n    // assert(nullifier == expected_nullifier);\n}\n","path":"/home/msg-encrypted/Documents/dev/afk/afk-ignite/circuits/private_transfer/src/main.nr"}},"names":["main"],"brillig_names":[]}